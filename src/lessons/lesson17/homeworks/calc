/**
 * РАСШИРЯЕМЫЙ ТЕКСТОВЫЙ КАЛЬКУЛЯТОР
 * 
 * Архитектура:
 * - Абстрактный класс Operation определяет интерфейс для всех операций
 * - Конкретные операции (Addition, Subtraction и т.д.) наследуются от Operation
 * - Класс Calculator управляет списком операций и выполняет вычисления
 * - Можно добавлять пользовательские операции без изменения кода калькулятора
 */

// ============= АБСТРАКТНЫЙ КЛАСС ОПЕРАЦИИ =============

abstract class Operation {
    /**
     * Проверяет, применима ли данная операция к выражению
     * @param expression - строка вида "3 + 4"
     * @return true, если операция применима
     */
    abstract fun isApplicable(expression: String): Boolean
    
    /**
     * Выполняет операцию над выражением
     * @param expression - строка вида "3 + 4"
     * @return результат операции в виде строки
     */
    abstract fun execute(expression: String): String
    
    /**
     * Извлекает оператор из выражения
     * @param expression - строка вида "3 + 4"
     * @return оператор (например, "+")
     */
    protected abstract fun getOperator(): String
    
    /**
     * Разбивает выражение на операнды
     * @param expression - строка вида "3 + 4"
     * @return пара операндов
     */
    protected fun parseOperands(expression: String): Pair<String, String>? {
        val operator = getOperator()
        val parts = expression.split(operator)
        
        return if (parts.size == 2) {
            Pair(parts.trim(), parts.trim())
        } else {
            null
        }
    }
    
    /**
     * Преобразует строку в число
     */
    protected fun toNumber(operand: String): Double? {
        return operand.toDoubleOrNull()
    }
}

// ============= ВСТРОЕННЫЕ ОПЕРАЦИИ (INTERNAL) =============
// Эти классы доступны только внутри модуля калькулятора

internal class Addition : Operation() {
    override fun getOperator(): String = "+"
    
    override fun isApplicable(expression: String): Boolean {
        return expression.contains("+") && parseOperands(expression) != null
    }
    
    override fun execute(expression: String): String {
        val (left, right) = parseOperands(expression) ?: return "Ошибка разбора"
        val leftNum = toNumber(left) ?: return "Ошибка: '$left' не число"
        val rightNum = toNumber(right) ?: return "Ошибка: '$right' не число"
        
        return (leftNum + rightNum).toString()
    }
}

internal class Subtraction : Operation() {
    override fun getOperator(): String = "-"
    
    override fun isApplicable(expression: String): Boolean {
        // Проверяем, что минус не в начале (не унарный)
        val trimmed = expression.trim()
        if (trimmed.startsWith("-")) return false
        return expression.contains("-") && parseOperands(expression) != null
    }
    
    override fun execute(expression: String): String {
        val (left, right) = parseOperands(expression) ?: return "Ошибка разбора"
        val leftNum = toNumber(left) ?: return "Ошибка: '$left' не число"
        val rightNum = toNumber(right) ?: return "Ошибка: '$right' не число"
        
        return (leftNum - rightNum).toString()
    }
}

internal class Multiplication : Operation() {
    override fun getOperator(): String = "*"
    
    override fun isApplicable(expression: String): Boolean {
        return expression.contains("*") && parseOperands(expression) != null
    }
    
    override fun execute(expression: String): String {
        val (left, right) = parseOperands(expression) ?: return "Ошибка разбора"
        val leftNum = toNumber(left) ?: return "Ошибка: '$left' не число"
        val rightNum = toNumber(right) ?: return "Ошибка: '$right' не число"
        
        return (leftNum * rightNum).toString()
    }
}

internal class Division : Operation() {
    override fun getOperator(): String = "/"
    
    override fun isApplicable(expression: String): Boolean {
        return expression.contains("/") && parseOperands(expression) != null
    }
    
    override fun execute(expression: String): String {
        val (left, right) = parseOperands(expression) ?: return "Ошибка разбора"
        val leftNum = toNumber(left) ?: return "Ошибка: '$left' не число"
        val rightNum = toNumber(right) ?: return "Ошибка: '$right' не число"
        
        if (rightNum == 0.0) {
            return "Ошибка: деление на ноль"
        }
        
        return (leftNum / rightNum).toString()
    }
}

internal class Modulo : Operation() {
    override fun getOperator(): String = "%"
    
    override fun isApplicable(expression: String): Boolean {
        return expression.contains("%") && parseOperands(expression) != null
    }
    
    override fun execute(expression: String): String {
        val (left, right) = parseOperands(expression) ?: return "Ошибка разбора"
        val leftNum = toNumber(left) ?: return "Ошибка: '$left' не число"
        val rightNum = toNumber(right) ?: return "Ошибка: '$right' не число"
        
        if (rightNum == 0.0) {
            return "Ошибка: деление на ноль"
        }
        
        return (leftNum % rightNum).toString()
    }
}

// ============= КЛАСС КАЛЬКУЛЯТОРА =============

class Calculator {
    private val operations: MutableList<Operation> = mutableListOf()
    
    init {
        // Регистрируем встроенные операции
        registerStandardOperations()
    }
    
    /**
     * Регистрация стандартных операций
     */
    private fun registerStandardOperations() {
        operations.add(Addition())
        operations.add(Subtraction())
        operations.add(Multiplication())
        operations.add(Division())
        operations.add(Modulo())
    }
    
    /**
     * Добавление пользовательской операции
     * @param operation - объект класса, наследующего Operation
     */
    fun addOperation(operation: Operation) {
        operations.add(operation)
    }
    
    /**
     * Вычисление выражения
     * @param expression - строка вида "3 + 4"
     * @return результат в виде строки
     */
    fun calculate(expression: String): String {
        val trimmedExpression = expression.trim()
        
        // Ищем подходящую операцию
        for (operation in operations) {
            if (operation.isApplicable(trimmedExpression)) {
                return operation.execute(trimmedExpression)
            }
        }
        
        return "Ошибка: неподдерживаемая операция"
    }
}

// ============= ПОЛЬЗОВАТЕЛЬСКИЕ ОПЕРАЦИИ (ПРИМЕРЫ) =============

/**
 * Пример пользовательской операции - возведение в степень
 */
class PowerOperation : Operation() {
    override fun getOperator(): String = "^"
    
    override fun isApplicable(expression: String): Boolean {
        return expression.contains("^") && parseOperands(expression) != null
    }
    
    override fun execute(expression: String): String {
        val (left, right) = parseOperands(expression) ?: return "Ошибка разбора"
        val base = toNumber(left) ?: return "Ошибка: '$left' не число"
        val exponent = toNumber(right) ?: return "Ошибка: '$right' не число"
        
        return Math.pow(base, exponent).toString()
    }
}

/**
 * Пример пользовательской операции - конкатенация строк
 */
class ConcatenationOperation : Operation() {
    override fun getOperator(): String = "&"
    
    override fun isApplicable(expression: String): Boolean {
        return expression.contains("&") && parseOperands(expression) != null
    }
    
    override fun execute(expression: String): String {
        val (left, right) = parseOperands(expression) ?: return "Ошибка разбора"
        // Не преобразуем в числа - работаем со строками
        return left + right
    }
}

// ============= ТЕСТИРОВАНИЕ =============

fun main() {
    val calculator = Calculator()
    
    println("=== ТЕСТИРОВАНИЕ ВСТРОЕННЫХ ОПЕРАЦИЙ ===")
    
    // Тесты базовых операций
    val tests = listOf(
        "3 + 4",
        "10 - 5",
        "6 * 7",
        "20 / 4",
        "17 % 5",
        "100 / 0",  // Деление на ноль
        "abc + 5",  // Некорректный операнд
        "5 # 3"     // Неподдерживаемая операция
    )
    
    tests.forEach { expression ->
        val result = calculator.calculate(expression)
        println("$expression = $result")
    }
    
    println("\n=== ДОБАВЛЕНИЕ ПОЛЬЗОВАТЕЛЬСКИХ ОПЕРАЦИЙ ===")
    
    // Добавляем возведение в степень
    calculator.addOperation(PowerOperation())
    println("2 ^ 3 = ${calculator.calculate("2 ^ 3")}")
    println("5 ^ 2 = ${calculator.calculate("5 ^ 2")}")
    
    // Добавляем конкатенацию строк
    calculator.addOperation(ConcatenationOperation())
    println("Hello & World = ${calculator.calculate("Hello & World")}")
    println("123 & 456 = ${calculator.calculate("123 & 456")}")
    
    println("\n=== ДОПОЛНИТЕЛЬНЫЕ ТЕСТЫ ===")
    println("15.5 + 4.5 = ${calculator.calculate("15.5 + 4.5")}")
    println("100.0 / 3.0 = ${calculator.calculate("100.0 / 3.0")}")
    println("2.5 * 4 = ${calculator.calculate("2.5 * 4")}")
}
